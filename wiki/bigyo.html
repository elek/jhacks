<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>JHacks</title>

    <link rel="stylesheet" href="../stylesheets/styles.css">
    <link rel="stylesheet" href="../stylesheets/pygment_trac.css">
    <script src="../javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!-- 3 -->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">JHacks</h1>
        <p class="header">#java #wiki #hu [ARCHIVE_ONLY!]</p>

        <ul>
          <li class="download"><a class="buttons" href="../index.html">Mi ez?</a></li>
          <li class="download"><a class="buttons" href="../List.html">Oldalindex</a></li>
        </ul>

        <p class="header">This archive is hosted on <a class="header name" href="https://github.com/elek/jhacks">github</a></p>


      </header>
      <section>
	<h1>Nevezhetném __MégEgyÚjabbKomponensKeretrendszernek__ de a __bigyo__ rövidebbnek tünt.</h1>
<p>Miért is irtam? </p>
<ol>
  <li>mert ráértem...</li>
  <li>miért ne?</li>
  <li>azért mert nem találtam olyan IoC frameworkot ami az igényeimet kielégitette volna. (S itt most szigoruan programozás beli igényeimre gondolok) <br/></li>
</ol><p>Nevezetesen:</p>
<ol>
  <li>komponensek közötti függőségek kezelése, s minél transzparensebb felinicalizálása. Mondjuk set-terekkel.</li>
  <li>a rendszer intelligensen kezelje a komponens konfigurációját, olyan szinten, hogy ha a VM-ben a komponens megváltoztat valami paramétert, akkor transzparens módon ez megjelenjen a fájl rendszerben. Valamint a másik irányban, ha az ember módositja futás közben a konfig fájlt, akkor erről a komponens értesüljön, s tudjon rá érdemben reagálni.</li>
  <li>Az előzőböl következik, hogy mind emberi mind gépi "kézzel" fájdalom nélkül lehessen szerkeszteni.</li>
  <li>JMX-el is lehessen konfigurálni.</li>
</ol><p>Igazából a 2-es funkciót hiányzott nagyon, de nem láttam sehol sem.  Úgyhogy végig gondoltam, hogy hogyan szeretnék komponenseket programozni:</p>
<ul>
  <li>a perzisztens konfiguráció élesen válljon el a többitől, a konfiguráció legyen egy POJO. Alapvetően nehézkes ötletnek tartom az <a href="avalon.html">avalon</a>-os <a href="Missing.html">Configuration</a> interface-ét) Engem nem (nagyon) érdekel, hogy van letárolva. Pláne amikor "büzlik" az olyan jellegü conf.getChild("widget").getAttribute("name"), hogy itt bizony a fejlesztők (namespace-es) XML-en kivül mást el se nagyon birtak képzelni.</li>
  <li>A konfiguráció legyen egyszerü, és tipusos (tetszőleges tipusokkal természetesen!). A myConfig.getServerName() mondjuk adjon vissza egy String-et, a myConfig.getFile() meg egy File objektumot, esetleg a myConfig.getMiscMap() meg egy Map-et.</li>
  <li>Ne a komponens programozójának kelljen bonyolult módon egy DOM-ból kibányászni az információkat.</li>
  <li>a más komponensen való függőségeket a komponensem kapja meg set-terrel. De ha kell akkor tetszőleges komponenst meg tudjon szerezni (lásd: avalon ServiceManager).</li>
  <li>ha lehet ne kelljen semmilyen interfacet implementálni a komponensnek. Sőt, a komponensek akkor is müködhessenek, ha nincs a közelben a container. (lásd JUnit tesztelhetőség - mer anélkül nem élünk :) )</li>
</ul><p>Valamint telepítéskor: </p>
<ul>
  <li>Lehessen megadni, hogy melyik komponens "startup" melyiket csak akkor jöjjön létre, ha szükség van rá.</li>
  <li>Minimális - parancssori - változtatásokkal lehessen módositani, hogy milyen komponens halmazok - azaz profile-ok - legyenek aktivak. Pl <strong>./runserver --profile=webserver --profile=jmx</strong> esetén inditsa el azokat a komponenseket amik a "webserver" illetve a "jmx" szolgáltatáshoz szükségesek.</li>
</ul><p>Nos, ezeket a célokat már a bigyo tudja.</p><p>Ráadásul elérhető a <a href="http://bigyo.sourceforge.net">http://bigyo.sourceforge.net</a> cimen :)</p><p>Ha bárki bármit értett belőle, akkor szóljon :)</p><h1><a href="avalon.html">avalon</a> komponensek <a href="bigyo.html">bigyo</a> komponensekké alakítása.</h1><p>A két rendszer nem ugyanazokat a szolgáltatásokat nyújtja a komponenseinek ezért a portolás se nem teljesen zökkenőmentes, se nem teljesen gépiesíthető. </p><h1>Avalon interfacek megfeleltetései:</h1>
<ul>
  <li>LogEnabled/Logger :</li>
</ul><p>Log4j eddig bőven elég volt minden eddigi loggolási igényemhez, nem akartam feltalálni újra a spanyol viaszt. Ha mégis ilyen stilusu loggolást akarnánk használni akkor a következőt kell tennünk: <code>
 /**
  * A metodus nev tetszoleges lehet.... 
  * @bigyo-depend logger
  */
  public void setSajatLogger(Logger log) {
</code></p><p>S majd a példány konfigurációjában meg kell adnunk, hogy melyik - szintén általunk felkonfigurált - Logger példányt szeretnénk használni.</p>
<ul>
  <li>Context : ahogy látom ez teljes egészében megfelel a bigyo tipusos konfiguráció fogalmával. Ezután a :</li>
</ul>
<pre><code>  File file = (File)context.get(&quot;myFile&quot;);
</code></pre><p>helyett a <code>
  File file = config.getMyFile();
</code>  kell hivni. Most mondja valaki, hogy nem egyszerübb :)</p>
<ul>
  <li>Configuration/Parameters : szintén az egyszerübb, s testre szabhatóbb saját konfigurációs beanunket használhatjuk.</li>
  <li>Servicable/ServiceManager : egyrészt a setterekkel definiált serviceket megkapjuk automatikusan a bigyo-tól (ahogy a Logger-nél is irtam) másrészt ha ennél dinamikusabban szeretnénk meg kapni a komponenseinket, akkor</li>
</ul>
<pre><code> /**
* @bigyo-depend bigyo:service-locator
*/
public setServiceLocator(net.sf.bigyo.api.ServiceLocator locator)
</code></pre><p>metodus deklarálásával, s a locator segitségével magunkhoz ragadhatunk tetszőleges komponenst. Jelenleg nem lehet release-elni egy komponenst, ha már megszereztük.</p>
<ul>
  <li>Lifecycle interface-k: az egész le van egyszerüsitve. Egy komponens megadhat egy start és egy stop metódust (a @bigyo-start és @bigyo-stop tag-gel) s azok a megfelelő időpontban meg lesznek hivva. Még annyi különbség van az avalon lifecycle-hoz képest - s ez különösen az indulásnál látszik - hogy a bigyo elinditáskor elöször létrehozza az összes komponenst, meg hivja a megfelelő set-ter metódusokat, aztán amikor minden példány létezik utánna egy menetben hivja végig az összes start metódust.</li>
</ul>


      </section>
      <footer>
        
        <p><small>Last change: 2006-03-26</small></p>
        
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a></small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		
  </body>
</html>
